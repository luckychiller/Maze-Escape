Enhanced Project Structure Suggestion
MAZE ESCAPE:.
│   .gitignore
│   CMakeLists.txt
│   overview.txt
│   README.md
│
├───build
│       (CMake generated files)
│
├───external
│   │   stb_image.c       // Implementation file for stb_image
│   │   stb_image.h
│   ├───glad
│   │   └───src
│   │       └───glad.c    // GLAD implementation file
│   ├───glfw
│   │       (GLFW library files, or header-only if built separately)
│   └───glm
│           (GLM header files)
│
├───shaders
│   │   wall.frag
│   │   wall.vert
│   │   floor.frag
│   │   floor.vert
│   │   exit.frag
│   │   exit.vert
│   │   skybox.frag     // For later
│   │   skybox.vert     // For later
│
├───src
│   │   main.cpp
│   │
│   ├───Core
│   │   │   Application.h
│   │   │   Application.cpp
│   │   │   Input.h
│   │   │   Input.cpp
│   │   │   Time.h         // For delta time calculation
│   │   │   Time.cpp
│   │
│   ├───Graphics
│   │   │   Camera.h
│   │   │   Camera.cpp
│   │   │   Mesh.h         // Represents VAO, VBO, EBO, vertex count
│   │   │   Mesh.cpp
│   │   │   Model.h        // Could be a collection of meshes, or a simpler primitive
│   │   │   Model.cpp
│   │   │   Renderer.h     // Handles draw calls, clear screen etc.
│   │   │   Renderer.cpp
│   │   │   Shader.h
│   │   │   Shader.cpp
│   │   │   Texture.h
│   │   │   Texture.cpp
│   │   │   Light.h        // For later (e.g. point lights, directional light)
│   │   │   Light.cpp
│   │
│   ├───Game
│   │   │   Maze.h
│   │   │   Maze.cpp
│   │   │   Player.h
│   │   │   Player.cpp
│   │   │   GameLogic.h    // Manages game state, win/lose conditions
│   │   │   GameLogic.cpp
│   │
│   └───Utils
│       │   FileSystem.h   // Helper for paths
│       │   FileSystem.cpp
│       │   Logging.h      // Simple logging
│       │   Logging.cpp
│
└───textures
    │   wall.png
    │   floor.png
    │   ceiling.png
    │   exit_sign.png
    │   skybox_right.jpg  // For later
    │   skybox_left.jpg
    │   skybox_top.jpg
    │   skybox_bottom.jpg
    │   skybox_front.jpg
    │   skybox_back.jpg


Why these changes/additions?
stb_image.c and glad.c: These libraries often require one .c file to be compiled into your project.
src/Core: For fundamental application-level concerns like the main loop, input handling, and time management.
src/Graphics: All OpenGL-specific rendering code, camera, shaders, textures, meshes.
src/Game: Game-specific logic like maze generation, player state, win conditions.
src/Utils: General utility functions that don't fit elsewhere.
More specific shader files (you'll likely want different shaders for different objects).
More specific texture files.

Overall Steps to Build the Maze Escape Game

Here's a high-level roadmap:

################### completed ##########################
Phase 0: Project Setup & Basic Window
Environment Setup: Ensure compiler, CMake, and necessary development tools are installed.
CMake Configuration: Write CMakeLists.txt to include GLFW, GLAD, GLM, and stb_image.
Window Creation: Use GLFW to create an OpenGL window.
GLAD Initialization: Initialize GLAD to load OpenGL function pointers.
Basic Game Loop: Create a loop that keeps the window open, processes input, and clears the screen to a color.

Phase 1: Rendering Basics - The First Cube
6. Shader Class: Create a Shader class to load, compile, and link vertex and fragment shaders from files.
7. Vertex Data: Define vertices for a simple cube.
8. Buffers (VBO, VAO, EBO): Create Vertex Buffer Objects (VBOs) to send vertex data to the GPU, and Vertex Array Objects (VAOs) to store buffer configurations. Use Element Buffer Objects (EBOs) for indexed drawing.
9. Basic Shaders: Write simple vertex and fragment shaders to draw the cube in a solid color.
10. Transformations (MVP Matrices): Introduce Model, View, and Projection matrices using GLM. Send them to the shader as uniforms.
11. Camera Class (Static): Create a basic Camera class that manages the View and Projection matrices. Initially, it can be static.
12. Render a Cube: Draw the cube using the shaders and transformations.

Phase 2: First-Person Camera & Movement
13. Camera Movement: Enhance the Camera class to support first-person movement (forward/backward, strafe left/right) and mouse-look (pitch/yaw).
14. Input Handling: Implement input processing (keyboard for movement, mouse for looking) in Input.cpp and use it in Application.cpp to update the camera.
15. Delta Time: Implement time-step independence for smooth movement across different hardware.

Phase 3: Procedural Maze Generation
16. Maze Data Structure: Define a Cell struct/class and a 2D grid (e.g., std::vector<std::vector<Cell>>) to represent the maze. Each cell should know about its walls (e.g., bool N, S, E, W).
17. Maze Generation Algorithm: Implement a maze generation algorithm. Recursive Backtracker is a good choice as it tends to create long corridors and guarantees a path.
* Mark start and end cells.
* Ensure the "no isolated cell/row" constraint is met (Recursive Backtracker usually handles this well if it explores the whole grid).
18. Maze Class: Encapsulate the maze data and generation logic within a Maze class.

Phase 4: Rendering the Maze
19. Wall Geometry: Decide how to represent walls. Individual cubes are straightforward to start with.
20. Floor and Ceiling: Create large quads for the floor and ceiling.
21. Instancing (Optional but Recommended): If using many identical wall cubes, consider instanced rendering for performance. For now, drawing individual cubes is fine.
22. Renderer Class: Refactor drawing logic into a Renderer class.
23. Maze Traversal & Rendering: Iterate through your Maze data structure. For each cell, determine where walls exist and render a cube (or quad) at that position.
24. Texture Loading: Create a Texture class using stb_image.h to load image files (e.g., wall.png, floor.png).
25. Texturing: Apply textures to walls, floor, and ceiling using texture coordinates in your vertex data and sampler2D uniforms in your fragment shaders.

Phase 5: Player Interaction & Game Logic
26. Player Class: Create a Player class. It will hold its position, size (for collision), and potentially link to the Camera.
27. Collision Detection (AABB): Implement Axis-Aligned Bounding Box (AABB) collision detection between the player and the maze walls.
28. Collision Response: Prevent the player from moving through walls.
29. Exit Condition: Define the "exit" cell. Render a distinct visual cue there (e.g., a textured quad with an "EXIT" sign).
30. Win Condition: In your game loop/GameLogic class, check if the player's position overlaps with the exit cell.
31. Game State: Introduce a simple game state (e.g., PLAYING, WON).

Phase 6: Polish and Enhancements
32. Basic Lighting: Implement simple Phong lighting (ambient, diffuse, specular) to give the scene more depth. Start with a single directional light or point light.
############### here we are ################
33. Skybox: Add a skybox for a more immersive environment.
34. User Interface (Minimal): Display simple text like "Find the Exit!" or "You Won!" (This can be tricky in raw OpenGL; consider a library like Dear ImGui for complex UI later, or simple textured quads for now).
35. Sound Effects (Optional): Add footstep sounds, a win sound. (Requires an audio library like OpenAL or SDL_mixer).

Phase 7: Future Features (Monsters & Shooting)
36. Monster AI: Basic pathfinding (e.g., A* on the maze grid) or simpler "follow player if in sight" logic.
37. Monster Rendering: Create/load monster models and animate them.
38. Shooting Mechanics: Implement projectile launching, collision detection for projectiles.
39. Health System: For player and monsters.

Phase 8: Adding prefab Models
40. Load 3D models from OBJ files.
41. Create a Model class to handle model loading and rendering.
42. Integrate models into the game: player, monsters, projectiles, etc.

Phase 9: Menus and Game Levels.
43. Create a menu system for start, options, and exit.
44. Implement multiple levels with increasing difficulty.
45. Add power-ups and hazards.

Phase 11: Online Leaderboard (Optional)
46. Implement a simple online leaderboard.
47. Submit scores to a server.
48. Display top scores in the menu.

Phase 12: Online Mutiplayer Setup
49. Setup a server for multiplayer.
50. Implement client-server communication.
51. Synchronize game state between clients.

Phase 13: Ads and Monetization
52. Integrate ads (e.g., Google AdMob).
53. In-app purchases for premium features.

Phase 14: Optimization
54. Profile and optimize performance bottlenecks.
55. Implement level of detail (LOD) for distance objects.
56. Use instancing for repeated objects.

This is a marathon, not a sprint! 
Each step has its own learning curve. 
We'll tackle them one by one.



#######################################################

Excellent! Having basic Phong lighting implemented is a major visual upgrade. 
Your maze should look much more three-dimensional and atmospheric now.

We're still in Phase 6: Polish and Enhancements. 
The next logical step to enhance the visual immersion is Step 33: Skybox.

A skybox is essentially a large cube that surrounds your entire scene, textured on its inside faces with images of a sky or distant environment. This prevents the player from seeing into an empty void beyond the rendered scene.

Here's how we'll approach it:

Skybox Vertices: Define vertices for a large cube.

Cubemap Texture: Load 6 individual texture faces (front, back, top, bottom, left, right) into a single OpenGL cubemap texture object.

Skybox Shaders: Create new vertex and fragment shaders specifically for the skybox.

The vertex shader's main job is to pass through vertex positions and transform them using view/projection, but with a trick to ensure the skybox always appears behind everything else.

The fragment shader samples from the cubemap texture.

Rendering the Skybox: Draw the skybox cube first in your render loop (or last with depth testing tricks).

Step 33.1: Skybox Vertices

We can reuse a standard cube definition, but its coordinates will be used differently by the skybox vertex shader.
(In main.cpp for now, or create a skybox-specific mesh)

float skyboxVertices[] = {
    // positions
    -1.0f,  1.0f, -1.0f, -1.0f, -1.0f, -1.0f,  1.0f, -1.0f, -1.0f,
     1.0f, -1.0f, -1.0f,  1.0f,  1.0f, -1.0f, -1.0f,  1.0f, -1.0f,

    -1.0f, -1.0f,  1.0f, -1.0f, -1.0f, -1.0f, -1.0f,  1.0f, -1.0f,
    -1.0f,  1.0f, -1.0f, -1.0f,  1.0f,  1.0f, -1.0f, -1.0f,  1.0f,

     1.0f, -1.0f, -1.0f,  1.0f, -1.0f,  1.0f,  1.0f,  1.0f,  1.0f,
     1.0f,  1.0f,  1.0f,  1.0f,  1.0f, -1.0f,  1.0f, -1.0f, -1.0f,

    -1.0f, -1.0f,  1.0f, -1.0f,  1.0f,  1.0f,  1.0f,  1.0f,  1.0f,
     1.0f,  1.0f,  1.0f,  1.0f, -1.0f,  1.0f, -1.0f, -1.0f,  1.0f,

    -1.0f,  1.0f, -1.0f,  1.0f,  1.0f, -1.0f,  1.0f,  1.0f,  1.0f,
     1.0f,  1.0f,  1.0f, -1.0f,  1.0f,  1.0f, -1.0f,  1.0f, -1.0f,

    -1.0f, -1.0f, -1.0f, -1.0f, -1.0f,  1.0f,  1.0f, -1.0f, -1.0f,
     1.0f, -1.0f, -1.0f, -1.0f, -1.0f,  1.0f,  1.0f, -1.0f,  1.0f
};
// No indices needed for skybox if drawing with glDrawArrays and vertices are defined for 36 points.
// Or define 8 unique vertices and 36 indices. For simplicity, 36 vertices directly.


This defines a unit cube (36 vertices for 12 triangles).

Step 33.2: Cubemap Texture Loading

You'll need 6 images for the skybox faces. The order typically matters for loading into a cubemap. A common order is:

Right (GL_TEXTURE_CUBE_MAP_POSITIVE_X)

Left (GL_TEXTURE_CUBE_MAP_NEGATIVE_X)

Top (GL_TEXTURE_CUBE_MAP_POSITIVE_Y)

Bottom (GL_TEXTURE_CUBE_MAP_NEGATIVE_Y)

Front (GL_TEXTURE_CUBE_MAP_POSITIVE_Z) (often called "back" in some conventions)

Back (GL_TEXTURE_CUBE_MAP_NEGATIVE_Z) (often called "front")

Let's assume you have these files in textures/skybox/:

textures/skybox/right.jpg

textures/skybox/left.jpg

textures/skybox/top.jpg

textures/skybox/bottom.jpg

textures/skybox/front.jpg

textures/skybox/back.jpg

We'll need a new function or modify our Texture class to load cubemaps. For now, let's create a standalone function in main.cpp or a helper file.

Function to load a cubemap (e.g., in main.cpp or a new Utils/TextureLoader.cpp):

// Helper function to load a cubemap
unsigned int loadCubemap(const std::vector<std::string>& faces, bool flipVerticallyOnLoad = false) {
    unsigned int textureID;
    glGenTextures(1, &textureID);
    glBindTexture(GL_TEXTURE_CUBE_MAP, textureID);

    stbi_set_flip_vertically_on_load(flipVerticallyOnLoad); // Usually false for cubemaps from common tools

    int width, height, nrChannels;
    for (unsigned int i = 0; i < faces.size(); i++) {
        unsigned char *data = stbi_load(faces[i].c_str(), &width, &height, &nrChannels, 0);
        if (data) {
            GLenum format = GL_RGB;
            if (nrChannels == 1) format = GL_RED;
            else if (nrChannels == 3) format = GL_RGB;
            else if (nrChannels == 4) format = GL_RGBA;

            glTexImage2D(GL_TEXTURE_CUBE_MAP_POSITIVE_X + i,
                         0, format, width, height, 0, format, GL_UNSIGNED_BYTE, data);
            stbi_image_free(data);
            std::cout << "Cubemap texture loaded: " << faces[i] << std::endl;
        } else {
            std::cerr << "Cubemap texture failed to load at path: " << faces[i] << std::endl;
            stbi_image_free(data); // data is null, but call for consistency
            return 0; // Return 0 on failure
        }
    }
    glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
    glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
    glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
    glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
    glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_R, GL_CLAMP_TO_EDGE); // For the R coord of cubemap

    glBindTexture(GL_TEXTURE_CUBE_MAP, 0); // Unbind
    return textureID;
}
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
C++
IGNORE_WHEN_COPYING_END

stbi_set_flip_vertically_on_load(false): Often, cubemap faces are already oriented correctly, so flipping might not be needed. Test this.

GL_TEXTURE_CUBE_MAP_POSITIVE_X + i: This conveniently maps the loop index to the correct cubemap face enum.

GL_CLAMP_TO_EDGE: Important for wrap mode to avoid seams at cube edges.

Step 33.3: Skybox Shaders

shaders/skybox.vert:

#version 330 core
layout (location = 0) in vec3 aPos;

out vec3 TexCoords; // Will be the vertex position, used as direction vector

uniform mat4 projection;
uniform mat4 view; // View matrix without translation

void main() {
    TexCoords = aPos; // Pass vertex position directly as texture coordinate for cubemap
    
    // Remove translation from the view matrix to make skybox follow camera
    mat4 viewNoTranslation = mat4(mat3(view)); 
    vec4 pos = projection * viewNoTranslation * vec4(aPos, 1.0);
    
    // Ensure skybox is always at the far plane (depth = 1.0)
    // This makes it render behind everything else.
    gl_Position = pos.xyww; 
}
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
Glsl
IGNORE_WHEN_COPYING_END

shaders/skybox.frag:

#version 330 core
out vec4 FragColor;

in vec3 TexCoords; // Direction vector from camera to cube vertex

uniform samplerCube skybox; // Cubemap sampler

void main() {    
    FragColor = texture(skybox, TexCoords);
}
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
Glsl
IGNORE_WHEN_COPYING_END

Key Shader Points:

skybox.vert:

TexCoords = aPos;: The local vertex position of the skybox cube is used as the 3D texture coordinate to sample the cubemap.

mat4 viewNoTranslation = mat4(mat3(view));: This clever trick removes the translation part of the view matrix. It ensures that no matter where the camera moves, the skybox remains centered around it, giving the illusion of being infinitely far away.

gl_Position = pos.xyww;: This is a depth trick. By setting z/w = w/w = 1.0, all fragments of the skybox will have the maximum depth value (1.0). If you render the skybox first and then your scene with depth testing enabled (glDepthFunc(GL_LEQUAL) or GL_LESS), the skybox will always be drawn behind everything else. An alternative is to draw skybox last and set glDepthFunc(GL_LEQUAL).

Step 33.4: Rendering the Skybox in main.cpp

// In main.cpp

// ... (includes, globals, callbacks, init functions) ...
// ... (camera, player, maze, renderer, other shaders, other textures, other meshes) ...

// Helper function loadCubemap (as defined above)

int main() {
    // ... (GLFW, GLAD, OpenGL setup) ...
    // ... (Renderer, Maze, Player, Camera setup) ...
    GLFWwindow* window = initializeWindow(); /* ... */
    if (!initializeGLAD()) { /* ... */ }
    setupOpenGL();
    Renderer renderer; // Assuming renderer.Clear() will be used

    int mazeGridW = 10; int mazeGridH = 8;
    Maze gameMaze(mazeGridW, mazeGridH); gameMaze.GenerateMaze(0,0); gameMaze.PrintToConsole();
    // ... (camera & player position setup) ...
    camera.Position = glm::vec3( (float)mazeGridW / 2.0f, wallHeight * 0.75f , (float)mazeGridH / 2.0f );
    camera.updateCameraVectors();
    player = std::make_unique<Player>(camera); player->SetPosition(camera.Position, gameMaze);


    // --- Shaders ---
    Shader wallShader("shaders/wall.vert", "shaders/wall.frag"); /* ... */
    Shader floorShader("shaders/floor.vert", "shaders/floor.frag"); /* ... */
    Shader skyboxShader("shaders/skybox.vert", "shaders/skybox.frag"); // New Skybox Shader
    if (skyboxShader.ID == 0) { std::cerr << "Failed to load skybox shader." << std::endl; return -1; }
    // (Error checks for other shaders)


    // --- Textures ---
    // ... (wallTexture, floorTexture, ceilingTexture, exitTexture) ...
    // Load Cubemap Texture
    std::vector<std::string> faces {
        "textures/skybox/right.jpg", "textures/skybox/left.jpg",
        "textures/skybox/top.jpg",   "textures/skybox/bottom.jpg",
        "textures/skybox/front.jpg", "textures/skybox/back.jpg"
    };
    unsigned int cubemapTextureID = loadCubemap(faces);
    if (cubemapTextureID == 0) { std::cerr << "Failed to load cubemap texture." << std::endl; return -1; }


    // --- Meshes ---
    // ... (cubeMesh, planeMesh, exitSignMesh) ...
    // Skybox Mesh (using the simple 36-vertex skyboxVertices array)
    float skyboxVertices[] = { /* ... as defined above (36 vertices * 3 floats) ... */
        -1.0f,  1.0f, -1.0f, -1.0f, -1.0f, -1.0f,  1.0f, -1.0f, -1.0f,  1.0f, -1.0f, -1.0f,  1.0f,  1.0f, -1.0f, -1.0f,  1.0f, -1.0f,
        -1.0f, -1.0f,  1.0f, -1.0f, -1.0f, -1.0f, -1.0f,  1.0f, -1.0f, -1.0f,  1.0f, -1.0f, -1.0f,  1.0f,  1.0f, -1.0f, -1.0f,  1.0f,
         1.0f, -1.0f, -1.0f,  1.0f, -1.0f,  1.0f,  1.0f,  1.0f,  1.0f,  1.0f,  1.0f,  1.0f,  1.0f,  1.0f, -1.0f,  1.0f, -1.0f, -1.0f,
        -1.0f, -1.0f,  1.0f, -1.0f,  1.0f,  1.0f,  1.0f,  1.0f,  1.0f,  1.0f,  1.0f,  1.0f,  1.0f, -1.0f,  1.0f, -1.0f, -1.0f,  1.0f,
        -1.0f,  1.0f, -1.0f,  1.0f,  1.0f, -1.0f,  1.0f,  1.0f,  1.0f,  1.0f,  1.0f,  1.0f, -1.0f,  1.0f,  1.0f, -1.0f,  1.0f, -1.0f,
        -1.0f, -1.0f, -1.0f, -1.0f, -1.0f,  1.0f,  1.0f, -1.0f, -1.0f,  1.0f, -1.0f, -1.0f, -1.0f, -1.0f,  1.0f,  1.0f, -1.0f,  1.0f
    };
    unsigned int skyboxVAO, skyboxVBO;
    glGenVertexArrays(1, &skyboxVAO);
    glGenBuffers(1, &skyboxVBO);
    glBindVertexArray(skyboxVAO);
    glBindBuffer(GL_ARRAY_BUFFER, skyboxVBO);
    glBufferData(GL_ARRAY_BUFFER, sizeof(skyboxVertices), &skyboxVertices, GL_STATIC_DRAW);
    glEnableVertexAttribArray(0); // Position attribute
    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);
    glBindVertexArray(0);


    // Game state
    GameState currentGameState = GameState::PLAYING;
    glm::ivec2 exitCellCoords = {-1,-1}; /* ... find exit cell ... */
    for(int y=0;y<gameMaze.GetHeight();++y) for(int x=0;x<gameMaze.GetWidth();++x) if(gameMaze.GetCell(x,y).isEnd) exitCellCoords={x,y};


    // --- Game Loop ---
    while (!glfwWindowShouldClose(window)) {
        // ... (timing, input, player update, win condition check - same) ...
        float currentFrame = static_cast<float>(glfwGetTime());deltaTime = currentFrame - lastFrame;lastFrame = currentFrame;
        if(currentGameState == GameState::PLAYING){ processInput(window); if(player){player->Update(deltaTime, camera.Position, gameMaze);} if(player && player->CurrentCellX == exitCellCoords.x && player->CurrentCellY == exitCellCoords.y){currentGameState = GameState::WON; std::cout << "WON" << std::endl; glfwSetInputMode(window, GLFW_CURSOR, GLFW_CURSOR_NORMAL);}}
        else if (currentGameState == GameState::WON) { if(glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS) glfwSetWindowShouldClose(window, true); }


        renderer.Clear(); // Clears color and depth
        // renderer.BeginScene(camera, (float)SCR_WIDTH, (float)SCR_HEIGHT); // Not strictly needed if VP set per shader

        glm::mat4 projection = camera.GetProjectionMatrix((float)SCR_WIDTH, (float)SCR_HEIGHT);
        glm::mat4 view = camera.GetViewMatrix();


        // --- Render Skybox ---
        // Draw skybox first with depth testing trick, or last with glDepthFunc(GL_LEQUAL)
        glDepthMask(GL_FALSE); // Turn off writing to the depth buffer
        // OR use glDepthFunc(GL_LEQUAL); before drawing skybox if drawing it last
        
        skyboxShader.use();
        glm::mat4 skyboxView = mat4(mat3(view)); // Remove translation from view matrix
        skyboxShader.setMat4("view", skyboxView);
        skyboxShader.setMat4("projection", projection);
        skyboxShader.setInt("skybox", 0); // Tell shader to use texture unit 0

        glBindVertexArray(skyboxVAO);
        glActiveTexture(GL_TEXTURE0);
        glBindTexture(GL_TEXTURE_CUBE_MAP, cubemapTextureID);
        glDrawArrays(GL_TRIANGLES, 0, 36);
        glBindVertexArray(0);
        glDepthMask(GL_TRUE); // Turn depth writing back on
        // If using glDepthFunc(GL_LEQUAL), reset it: glDepthFunc(GL_LESS);


        // --- Render Maze, Floor, Ceiling, Exit (as before) ---
        // Ensure their shaders get the full 'view' matrix, not 'skyboxView'
        // floorShader.use(); renderer.SetShaderMatrices(floorShader); // (Or set V/P directly)
        // ... (floor, ceiling, walls, exit rendering, ensure you set correct view matrix)

        // Example for floor:
        floorShader.use();
        floorShader.setMat4("view", view); // Use original view matrix
        floorShader.setMat4("projection", projection);
        // ... (rest of floor setup and submit)
        floorTexture->Bind(0); floorShader.setInt("floorTexture", 0); floorShader.setBool("isCeiling", false);
        glm::mat4 floorModel = glm::mat4(1.0f); /* ... */ floorModel = glm::translate(floorModel,glm::vec3((float)(mazeGridW-1)/2.0f,0.0f,(float)(mazeGridH-1)/2.0f)); floorModel = glm::scale(floorModel,glm::vec3((float)mazeGridW,1.0f,(float)mazeGridH));
        renderer.Submit(floorShader, *planeMesh, floorModel);
        
        ceilingTexture->Bind(0); floorShader.setInt("floorTexture", 0); floorShader.setBool("isCeiling", true);
        glm::mat4 ceilingModel = glm::mat4(1.0f); /* ... */ ceilingModel = glm::translate(ceilingModel,glm::vec3((float)(mazeGridW-1)/2.0f,wallHeight,(float)(mazeGridH-1)/2.0f)); ceilingModel = glm::scale(ceilingModel,glm::vec3((float)mazeGridW,1.0f,(float)mazeGridH));
        renderer.Submit(floorShader, *planeMesh, ceilingModel);

        wallShader.use();
        wallShader.setMat4("view", view); // Use original view matrix
        wallShader.setMat4("projection", projection);
        // ... (rest of wall setup and submit loop)
        wallTexture->Bind(0); wallShader.setInt("wallTexture", 0); // Sampler name from shader
        // (Add lighting uniforms for walls too)
        wallShader.setVec3("light_direction", lightDirGlobal); // Assuming lightDirGlobal is defined
        wallShader.setVec3("light_color", lightColorGlobal);   // Assuming lightColorGlobal is defined
        wallShader.setFloat("light_ambientIntensity", ambientIntensityGlobal);
        wallShader.setVec3("viewPos", camera.Position);
        wallShader.setFloat("material_shininess", materialShininessGlobal);
        wallShader.setFloat("material_specularStrength", materialSpecularStrengthGlobal);

        for (int y = 0; y < gameMaze.GetHeight(); ++y) { /* ... */ 
            for (int x = 0; x < gameMaze.GetWidth(); ++x) {
                // ... same wall rendering logic using renderer.Submit ...
            }
        }

        // Exit Sign (ensure it uses the original 'view' matrix too)
        if (exitCellCoords.x != -1) {
            floorShader.use(); // Or exitShader
            floorShader.setMat4("view", view);
            floorShader.setMat4("projection", projection);
            // ... (rest of exit sign setup and submit) ...
            exitTexture->Bind(0); floorShader.setInt("floorTexture",0); floorShader.setBool("isCeiling",false);
            glm::mat4 exitModel = glm::mat4(1.0f); /* ... calculate exitModel ... */
            // (Copy the exitModel calculation from previous step)
            renderer.Submit(floorShader, *exitSignMesh, exitModel);
        }


        glfwSwapBuffers(window);
        glfwPollEvents();
    }

    // Cleanup Skybox VAO/VBO and cubemap texture
    glDeleteVertexArrays(1, &skyboxVAO);
    glDeleteBuffers(1, &skyboxVBO);
    glDeleteTextures(1, &cubemapTextureID);

    // ... (other cleanup) ...
    glfwDestroyWindow(window);
    glfwTerminate();
    return 0;
}

// Define light globals if not already (example)
glm::vec3 lightDirGlobal = glm::normalize(glm::vec3(0.5f, -1.0f, 0.7f));
glm::vec3 lightColorGlobal = glm::vec3(1.0f, 1.0f, 0.9f);
float ambientIntensityGlobal = 0.3f;
float materialShininessGlobal = 32.0f;
float materialSpecularStrengthGlobal = 0.4f;
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
C++
IGNORE_WHEN_COPYING_END

Key Changes in main.cpp for Skybox:

Skybox Shader & Texture Loading: New skyboxShader and cubemapTextureID are loaded.

Skybox VAO/VBO: Set up for the skyboxVertices. Note that this skybox mesh doesn't need texture coordinates or normals in its VBO because the fragment shader samples the cubemap using the vertex position itself.

Render Loop Order and Depth Testing for Skybox:

glDepthMask(GL_FALSE); is called before drawing the skybox. This prevents the skybox from writing to the depth buffer. Because its vertices are manipulated to always be at z/w = 1.0 (far plane), if it wrote to depth, it might occlude parts of the scene that are also far away.

Alternatively, if you draw skybox last: Set glDepthFunc(GL_LEQUAL); before drawing skybox, draw it, then reset glDepthFunc(GL_LESS);. The pos.xyww trick in the vertex shader ensures its depth is 1.0, so GL_LEQUAL will pass the depth test if the fragment being written to is currently 1.0 (cleared depth buffer or other skybox fragments).

skyboxView = mat4(mat3(view)); gets the view matrix without translation.

glActiveTexture(GL_TEXTURE0); glBindTexture(GL_TEXTURE_CUBE_MAP, cubemapTextureID); binds the cubemap.

glDrawArrays(GL_TRIANGLES, 0, 36); draws the skybox.

glDepthMask(GL_TRUE); re-enables depth writing for the rest of the scene.

View Matrix for Scene: Ensure that after rendering the skybox, the regular scene objects (maze, floor, etc.) are rendered using the original view matrix (with translation), not the skyboxView. My example now sets view/projection per shader group.

Lighting Uniforms: Make sure you're still setting lighting uniforms for your wall and floor shaders. I added placeholders lightDirGlobal, etc. you'll need to define these or pass them from where you set them up in the previous step.

Before Running:

Get Skybox Textures: Find/create 6 skybox images (e.g., search for "cubemap textures" or "skybox images"). Make sure they align correctly at the edges. Put them in textures/skybox/.

Update Texture Paths: In main.cpp, ensure the faces vector in loadCubemap points to your actual skybox image files.

Copy textures folder (including skybox subfolder) to build/bin/.

Create shaders/skybox.vert and shaders/skybox.frag with the provided code.

Add them to your build/bin/shaders/ directory.

Re-run CMake, build.

Expected Outcome:

You should see a sky (or whatever your cubemap images depict) surrounding your entire maze.

As you move and look around, the skybox should stay fixed relative to the distant horizon, creating a much more immersive environment.

This will be another significant visual improvement! Let me know how it goes.